{"version":3,"file":"code/code.js","mappings":"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","sources":["webpack://_new/./figma_lib/html_and_css.js","webpack://_new/./figma_lib/NodeManager.js","webpack://_new/./src/code/js/code.js"],"sourcesContent":["/**\n * Class for generating HTML code based on Figma node structure.\n */\nexport class HTMLGenerationForFigma {\n    /**\n     * Constructor for HTMLGenerationForFigma class.\n     * @param {Object} node - The Figma node for which HTML is generated.\n     * @param {Object} parent - The parent node.\n     * @param {Array} usedIds - Array of used IDs to ensure uniqueness.\n     */\n    constructor(node, parent = null, usedIds = [], variants = null, type) {\n        this.node = node;\n        this.parent = parent;\n        this.css = new CSSGenerationForFigma(node);\n        this.html = [];\n        this.usedIds = usedIds;\n        this.variants = variants;\n        this.type = type;\n        this.css  = new CSSGenerationForFigma(node, variants, type, this.html);\n          //    reduce variants to css name use name corrector to get class name\n    \n       if(this.variants){\n        // get variant vlaues;\n        let values = Object.values(this.variants);\n        // convert to css class\n        this.variant_css_class = values.reduce((acc,variant, index)=>{\n            if(index== 0) {\n                //  skip and return acc\n                return acc;\n            }\n            // if last item remove word default\n            return acc+`${this.nameCorrector(variant)} `\n        },\"\").replace(\"default\",\"\").trim();\n         \n       }else{\n              this.variant_css_class = \"\"\n         }\n       \n  \n        \n    }\n\n    /**\n     * Generate HTML code recursively for the Figma node.\n     * @param {number} indentation - Number of spaces for indentation.\n     * @param {Array} usedIds - Array of used IDs to ensure uniqueness.\n     * @returns {string} - The generated HTML code.\n     */\n    generator(indentation = 0, usedIds = this.usedIds, parent = null) {\n        // Skip the node if it's the same as the parent\n        if (this.shouldSkipNode()) {\n            return;\n        }\n   \n      \n        const correctedName = this.nameCorrector(this.node.name);\n        const id = this.generateUniqueId(correctedName, usedIds);\n        const linespacing = \"\\n\";\n        const indent = \" \".repeat(indentation * 2);\n        const elementBeginning = `${indent}${this.tagHandler(correctedName, id, this.node)}`;\n\n          \n        if(parent){\n            let parent_name = this.nameCorrector(parent.name);\n             let isText = [`h1`, `h2`, `h3`, `h4`, `h5`, `h6`, `p`, `span`].includes(parent_name);\n                if(isText){\n                    return `${indent} ${this.node.characters} \\n`;\n                }\n            }\n        \n        \n    \n        if (this.isImageElement(correctedName) || this.isInputElement(correctedName)) {\n            return elementBeginning;\n        }\n    \n        const elementEnd = `${indent}</${this.correctTagForNode()}>\\n`;\n    \n        // Recursively generate HTML for child nodes\n        this.generateHtmlForChildren(indentation, usedIds , this.node);\n    \n        const html = elementBeginning + this.html.join(linespacing) + elementEnd;\n         let unique_css_name = `\n          .${correctedName}${this.variant_css_class ? \".\"+this.variant_css_class : \"\"}\n         `;\n          \n        this.css.generator(unique_css_name, this.node, this.variants, this.type, this.parent, this.html);\n    \n        return html;\n    }\n    /**\n     * \n     * @returns {boolean} - True if it has base CSS properties, otherwise false.\n     *  \n     */\n    \n    shouldSkipNode() {\n        return this.parent && this.node.name.toLowerCase() === this.parent.name.toLowerCase();\n    }\n\n    /**\n     * \n     * @param {*} correctedName \n     * @returns  {boolean} - True if it an `img` element, otherwise false.\n     */\n    \n    isImageElement(correctedName) {\n        return correctedName === \"img\";\n    }\n\n    /**\n     * \n     * @param {*} correctedName \n     * @returns  {boolean} -  True if it an `input` element, otherwise false.\n     */\n    \n    isInputElement(correctedName) {\n        return correctedName === \"input\";\n    }\n\n\n    /**\n     * \n     * @param {*} indentation \n     * @param {*} usedIds \n     */\n    generateHtmlForChildren(indentation, usedIds, node) {\n        if (this.node.children) {\n            this.node.children.forEach(child => {\n                const childHtml = new HTMLGenerationForFigma(child, this.node);\n                this.html.push(childHtml.generator(indentation + 1, usedIds, node));\n            });\n        }\n    }\n    /**\n     * Determine the appropriate tag and handle accordingly.\n     * @param {string} correctedName - The corrected name of the Figma node.\n     * @param {string} id - The generated or dynamic ID for the node.\n     * @param {Object} node - The Figma node.\n     * @returns {string} - The HTML tag or attributes string.\n     */\n    tagHandler(correctedName, id, node) {\n        if(correctedName === \"image\")return this.imageAttributes(node);\n        if(correctedName === 'input') return this.inputAttributes(node);\n        return this.defaultElementBeginning(correctedName, id);\n     \n    }\n\n    /**\n     * Generate the default opening tag for the element.\n     * @param {string} correctedName - The corrected name of the Figma node.\n     * @param {string} id - The generated or dynamic ID for the node.\n     * @returns {string} - The opening tag string.\n     */\n    defaultElementBeginning(correctedName, id) {\n        return `<${this.correctTagForNode()} class=\"${correctedName} ${this.variant_css_class}\" id=\"${id}\">\\n`;\n    }\n\n    inputAttributes(node){\n        let correctedName = this.nameCorrector(node.name);\n        let placeholder = node.characters;\n        let type = node.type;\n        return `<input type=\"${type}\" class=\"${correctedName} ${ this.variant_css_class}\" placeholder=\"${placeholder}\" />\\n`;\n    }\n\n    /**\n     * Generate image attributes for an image node.\n     * @param {Object} node - The Figma node representing an image.\n     * @returns {string} - The image tag with alt and src attributes.\n     */\n    imageAttributes(node) {\n        let correctedName = this.nameCorrector(node.name);\n        // download image\n         let temp_image = \"https://picsum.photos/1600/800\";\n         return `<img class=\"img-fit\" alt=\"${correctedName}\" src=\"${ temp_image}\" />\\n`;\n    }\n\n    /**\n     * Correct the name of the Figma node for use in HTML.\n     * @param {string} name - The original name of the Figma node.\n     * @returns {string} - The corrected name.\n     */\n    nameCorrector(name) {\n      \n    //    lower case name \n        name = name.toLowerCase();\n        // remove spaces\n        name = name.replaceAll(\" \",\"-\");\n        // remove = sign\n        name = name.split(\"=\")[1] || name;\n        // check if name has surface\n        if(name.includes(\"surface\")){\n            return \"page-wrapper\";\n        }\n        return name;\n    }\n\n    /**\n     * Generate a unique ID for the Figma node based on the corrected name.\n     * @param {string} id - The corrected name of the Figma node.\n     * @param {Array} usedIds - Array of used IDs to ensure uniqueness.\n     * @returns {string} - The generated or dynamic ID.\n     */\n    generateUniqueId(id, usedIds) {\n        let unqiueId = id;\n        if (usedIds.includes(id)) {\n            const existingCount = usedIds.filter(_id => _id === id).length;\n            unqiueId = id + \"-\" + existingCount;\n        }\n        usedIds.push(id);\n        return unqiueId;\n    }\n\n    /**\n     * Determine the correct HTML tag based on the Figma node name.\n     * @returns {string} - The HTML tag.\n     */\n    correctTagForNode() {\n        const name = this.node.name.toLowerCase();\n    \n        const tagMap = {\n            \"button\": \"button\",\n            \"section\": \"section\",\n            \"image\": \"img\",\n            \"h1\": \"h1\",\n            \"h2\": \"h2\",\n            \"h3\": \"h3\",\n            \"h4\": \"h4\",\n            \"h5\": \"h5\",\n            \"h6\": \"h6\",\n            \"body-copy\": \"p\",\n            \"link\": \"a\",\n            \"list\": \"ul\",\n            \"list-item\": \"li\",\n            \"form\": \"form\",\n            \"input\": \"input\",\n            \"textarea\": \"textarea\",\n            \"label\": \"label\",\n            \"select\": \"select\",\n            \"option\": \"option\",\n            \"table\": \"table\",\n            \"table-row\": \"tr\",\n            \"table-cell\": \"td\",\n            \"table-header\": \"th\",\n            \"table-body\": \"tbody\",\n            \"table-head\": \"thead\",\n            \"table-foot\": \"tfoot\",\n            \"table-caption\": \"caption\",\n            \"article\": \"article\",\n            \"aside\": \"aside\",\n            \"details\": \"details\",\n            \"summary\": \"summary\",\n            \"figure\": \"figure\",\n            \"figcaption\": \"figcaption\",\n            \"main\": \"main\",\n        };\n    \n        return tagMap[name] || \"div\";\n    }\n    \n}\n\n/**\n * Class for generating CSS code based on Figma node structure.\n */\nexport class CSSGenerationForFigma  {\n    /**\n     * Constructor for CSSGenerationForFigma class.\n     * @param {Object} node - The Figma node for which CSS is generated.\n     */\n    constructor(node, variants = null, type) {\n        this.node = node;\n        this.variants = variants;\n        this.type = type;\n    \n \n    }\n\n     generator(unique_css_name, node, variants, type, parent) {\n      \n        const padding = this.getPadding(node, parent);\n        \n        const aspectRatio = this.getAspectRatio(node.width, node.height);\n      \n        const dimensions = this.checkMinMaxDimensions(node.minWidth, node.minHeight, node.maxWidth, node.maxHeight);\n         \n        const grid = this.generateGrid(node);\n       \n        // const layoutProperties = this.getLayoutProperties(node.layoutMode, node.mainAxis, node.spacing);\n        const backgroundProperties = this.getBackgroundProperties(node);\n        console.log(backgroundProperties,\"backgroundProperties\");\n        const borderProperties = this.getBorderProperties(node);\n        // const boxProperties = this.getBoxProperties(node.opacity, node.visible, node.locked, node.constraints, node.effects);\n        // const typeProperties = this.getTypeProperties(type);\n        // const textProperties = this.getTextProperties(type);\n        // const boxModelProperties = this.getBoxModelProperties(type);\n        // const spacingProperties = this.getSpacingProperties(type);\n        // const fillProperties = this.getFillProperties(type);\n        // const borderRadiusProperty = this.getBorderRadiusProperty(type);\n        // const colorProperties = this.getColorProperties(type);\n        // const textShadowProperty = this.getTextShadowProperty(type);\n        // const textLayoutProperties = this.getTextLayoutProperties(type);\n        // const listProperties = this.getListProperties(type);\n        // const cursorProperty = this.getCursorProperty(type);\n        // const outlineProperty = this.getOutlineProperty(type);\n        // const cssVariables = this.generateCSSVariables(variants);\n    \n        // Your main logic to apply the properties to the HTML or CSS representation\n         return;\n        // Example:\n        const styles = `\n            .${unique_css_name} {\n                padding: ${padding};\n                aspect-ratio: ${aspectRatio};\n                ${dimensions}\n                ${grid}\n                ${layoutProperties}\n                ${backgroundProperties}\n                ${borderProperties}\n                ${boxProperties}\n                ${typeProperties}\n                ${textProperties}\n                ${boxModelProperties}\n                ${spacingProperties}\n                ${fillProperties}\n                ${borderRadiusProperty}\n                ${colorProperties}\n                ${textShadowProperty}\n                ${textLayoutProperties}\n                ${listProperties}\n                ${cursorProperty}\n                ${outlineProperty}\n                ${cssVariables}\n            }\n        `;\n\n      \n    \n        return styles;\n    }\n    getPadding(node,){\n        let paddingLeft = node.paddingLeft;\n        let paddingRight = node.paddingRight;\n        let paddingTop = node.paddingTop;\n        let paddingBottom = node.paddingBottom;\n        return `${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px`;\n\n    }\n    \n    getAspectRatio(width, height) {\n      let ratio =  width / height;\n   \n        return ratio;\n     \n        \n\n    }\n\n    getBorderProperties(node) {\n        const {\n            strokeAlign: borderInset,\n            strokeBottomWeight: borderBottomWidth,\n            strokeCap,\n            strokeGeometry,\n            strokeJoin,\n            strokeLeftWeight: borderLeftWidth,\n            strokeMiterLimit,\n            strokeRightWeight: borderRightWidth,\n            strokeStyleId,\n            strokeTopWeight: borderTopWidth,\n            strokeWeight: borderWidth,\n            strokes: borderColors,\n            topLeftRadius,\n            topRightRadius,\n            bottomLeftRadius,\n            bottomRightRadius,\n        } = node;\n        let   editable_border_colors  = JSON.parse(JSON.stringify(borderColors));\n          let borderColor  = editable_border_colors.reverse()[0];\n         if(!borderColor) return \"\";\n         let border_color_css;\n         if(borderColor) {\n              border_color_css   = `rgba(${Math.round(borderColor.color.r * 255)}, ${Math.round(borderColor.color.g * 255)}, ${Math.round(borderColor.color.b * 255)}, ${borderColor.opacity.toFixed(2)})`;\n            }\n \n    \n\n    \n        let styles = [\n           `border-width: ${borderTopWidth}px ${borderRightWidth}px ${borderBottomWidth}px ${borderLeftWidth}px`,\n            `border-style: solid`,\n            `border-color: ${border_color_css}`,\n            `border-radius: ${topLeftRadius}px ${topRightRadius}px ${bottomRightRadius}px ${bottomLeftRadius}px`,\n           \n           \n\n        ].filter(Boolean).join(';\\n');\n\n       console.log(styles, 'styles');\n\n    }\n\n     getBackgroundProperties(node) {\n    let styles = \"\";\n    let figmaData = node.fills;\n\n    figmaData.forEach((layer, index) => {\n        if (layer.type === 'SOLID' && layer.visible) {\n            const color = `rgba(${Math.round(layer.color.r * 255)}, ${Math.round(layer.color.g * 255)}, ${Math.round(layer.color.b * 255)}, ${layer.opacity.toFixed(2)})`;\n            styles += `background-color: ${color};\\n`;\n        } else if (layer.type === 'IMAGE' && layer.visible) {\n            let placeholder = \"https://picsum.photos/1600/800\";\n            styles += `background-image: url(${ placeholder});\\n`;\n            styles += `background-size: cover;\\n`;  // You can customize this based on your needs\n            styles += `background-repeat: no-repeat;\\n`;  // You can customize this based on your needs\n            styles += `background-position: center center;\\n`;  // You can customize this based on your needs\n        } else if (layer.type === 'GRADIENT_LINEAR' && layer.visible) {\n            const gradientStops = layer.gradientStops.map(stop => `rgba(${Math.round(stop.color.r * 255)}, ${Math.round(stop.color.g * 255)}, ${Math.round(stop.color.b * 255)}, ${stop.color.a.toFixed(2)}) ${stop.position.toFixed(2) * 100}%`).join(', ');\n\n            styles += `background: linear-gradient(${layer.gradientTransform[0][2].toFixed(2)}deg, ${gradientStops});\\n`;\n        }\n    });\n\n    return styles;\n}\n\n    checkMinMaxDimensions(minWidth, minHeight, maxWidth, maxHeight) {\n        let styles = \"\";\n        if (minWidth) {\n            styles += `min-width:${minWidth}px; \\n`;\n        }\n        if (minHeight) {\n            styles += `min-height:${minHeight}px; \\n`;\n        }\n        if (maxWidth) {\n            styles += `max-width:${maxWidth}px; \\n`;\n        }\n        if (maxHeight) {\n            styles += `max-height:${maxHeight}px; \\n`;\n        }\n        return styles;\n    }\n  \n      \n    generateGrid(node) {\n        if (node.name.toLowerCase() !== 'grid') return '';\n    \n        const width = node.width;\n        const children = node.children;\n        const templateColumns = children.map(child => (child.width / width) * 12).join('fr ') + 'fr';\n        let height = children[0].height;\n    \n        return `display: grid;\\ngrid-template-columns: ${templateColumns}; grid-template-rows: ${height}px;`;\n    }\n    \n    /**\n     * Check if the Figma node has base CSS properties.\n     * @returns {boolean} - True if it has base CSS properties, otherwise false.\n     */\n    baseCssForNode() {\n        const baseCssTags = ['surface-phone', 'surface-tablet', 'surface-laptop', 'surface-desktop'];\n\n        return baseCssTags.includes(this.node.name);\n    }\n}\n","/**\n * Class representing a manager for Figma nodes.\n * Helps in handling properties and generating HTML for nodes.\n */\nimport { HTMLGenerationForFigma, CSSGenerationForFigma } from \"./html_and_css\";\n\nclass NodeManager {\n    /**\n     * Constructor for NodeManager class.\n     * @param {Object} node - The Figma node to manage.\n     * @param {Array} useIds - Array of used IDs for HTML generation.\n     */\n    constructor(node, useIds) {\n        // Destructure node properties for cleaner assignment\n        const {\n            name,\n            type,\n            layoutMode: autoLayout,\n            fills: fill,\n            paddingTop,\n            paddingBottom,\n            paddingLeft,\n            paddingRight,\n            itemSpacing: spacing,\n            primaryAxisAlignItems: direction,\n            counterAxisAlignItems: counterAxis,\n            height,\n            width,\n            x,\n            y,\n            rotation,\n            opacity,\n            visible,\n            locked,\n            constraints,\n            effects,\n            parent,\n            children,\n            description: desc,\n            variantProperties: variants\n        } = node;\n\n        // Initialize properties with destructured values\n        this.node = node;\n        this.name = name;\n        this.type = type;\n        this.autoLayout = autoLayout;\n        this.fill = fill;\n        this.paddingTop = paddingTop;\n        this.paddingBottom = paddingBottom;\n        this.paddingLeft = paddingLeft;\n        this.paddingRight = paddingRight;\n        this.spacing = spacing;\n        this.direction = direction;\n        this.counterAxis = counterAxis;\n        this.height = height;\n        this.width = width;\n        this.x = x;\n        this.y = y;\n        this.rotation = rotation;\n        this.opacity = opacity;\n        this.visible = visible;\n        this.locked = locked;\n        this.constraints = constraints;\n        this.effects = effects;\n        this.parent = parent;\n        this.children = this.getChildrenArray(children, useIds);\n        this.desc = desc;\n        this.variants = null;\n    \n        // Get text-related properties for text nodes\n        if (type === \"TEXT\") {\n            this.getTextProperties(node);\n        }\n\n        // Get variants for components\n        if (this.isComponentType()) {\n            this.variants = variants;\n          \n        }\n\n        this.html = new HTMLGenerationForFigma(node, null, useIds, this.variants, this.type);\n      \n    }\n\n    /**\n     * Get an array of child NodeManagers with visible true.\n     * @param {Array} children - The array of child nodes.\n     * @param {Array} useIds - Array of used IDs for HTML generation.\n     * @returns {Array} - Array of child NodeManagers.\n     */\n    getChildrenArray(children, useIds) {\n        return children\n            ? children.filter(child => child.visible === true).map(child => new NodeManager(child, useIds))\n            : [];\n    }\n\n    /**\n     * Get text-related properties for text nodes.\n     * @param {Object} node - The Figma text node.\n     */\n    getTextProperties(node) {\n        const { characters, fontSize, fontName, textAlignHorizontal, textAlignVertical } = node;\n        this.textValue = characters;\n        this.fontSize = fontSize;\n        this.fontFamily = fontName.family;\n        this.textAlign = textAlignHorizontal;\n        this.textVerticalAlign = textAlignVertical;\n        // Add more text-related properties as needed\n    }\n\n    /**\n     * Check if the node type is a component type.\n     * @returns {boolean} - True if the node is a component type, otherwise false.\n     */\n    isComponentType() {\n        return [\"COMPONENT\", \"INSTANCE\", \"COMPONENT_SET\"].includes(this.type);\n    }\n}\n\nexport default NodeManager;\n","import NodeManager from \"../../../figma_lib/NodeManager\";\n\nlet useIds = [];\n \n  \n//# sourceMappingURL=code.js.map  // Example usage\n  \n  const currentLayer = figma.currentPage.selection[0]\n\n  if(!currentLayer) {\n    figma.closePlugin(\"Please select a layer and try again\")\n  } else {\n    \n    const nodeManager = new NodeManager(currentLayer,  useIds);\n   let html =  nodeManager.html.generator()\n  \n  }\n \n\nfigma.closePlugin();"],"names":["HTMLGenerationForFigma","constructor","node","parent","usedIds","variants","type","this","css","CSSGenerationForFigma","html","values","Object","variant_css_class","reduce","acc","variant","index","nameCorrector","replace","trim","generator","indentation","shouldSkipNode","correctedName","name","id","generateUniqueId","indent","repeat","elementBeginning","tagHandler","parent_name","includes","characters","isImageElement","isInputElement","elementEnd","correctTagForNode","generateHtmlForChildren","join","unique_css_name","toLowerCase","children","forEach","child","childHtml","push","imageAttributes","inputAttributes","defaultElementBeginning","placeholder","replaceAll","split","unqiueId","existingCount","filter","_id","length","getPadding","getAspectRatio","width","height","checkMinMaxDimensions","minWidth","minHeight","maxWidth","maxHeight","generateGrid","backgroundProperties","getBackgroundProperties","console","log","getBorderProperties","paddingLeft","paddingRight","paddingTop","paddingBottom","strokeAlign","borderInset","strokeBottomWeight","borderBottomWidth","strokeCap","strokeGeometry","strokeJoin","strokeLeftWeight","borderLeftWidth","strokeMiterLimit","strokeRightWeight","borderRightWidth","strokeStyleId","strokeTopWeight","borderTopWidth","strokeWeight","borderWidth","strokes","borderColors","topLeftRadius","topRightRadius","bottomLeftRadius","bottomRightRadius","border_color_css","borderColor","JSON","parse","stringify","reverse","Math","round","color","r","g","b","opacity","toFixed","styles","Boolean","fills","layer","visible","gradientStops","map","stop","a","position","gradientTransform","baseCssForNode","NodeManager","useIds","layoutMode","autoLayout","fill","itemSpacing","spacing","primaryAxisAlignItems","direction","counterAxisAlignItems","counterAxis","x","y","rotation","locked","constraints","effects","description","desc","variantProperties","getChildrenArray","getTextProperties","isComponentType","fontSize","fontName","textAlignHorizontal","textAlignVertical","textValue","fontFamily","family","textAlign","textVerticalAlign","currentLayer","figma","currentPage","selection","closePlugin"],"sourceRoot":""}